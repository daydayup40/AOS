#《Linux kernel vulnerabilities》阅读报告
# 1. 论文概述
文章对2010.1~2011.3之间的linux内核相关漏洞进行了整理和分析，之后对现有的一些内核漏洞防御手段进行了回顾，发现这些防御手段都只能解决一部分类型的漏洞。最后文章讨论了语义逻辑漏洞、DoS漏洞这两个尚未得到有效解决的问题。
# 2. 漏洞回顾
内核漏洞可以分为10类，其中缓冲区溢出和整数溢出是内核安全最大威胁。内核相关漏洞有2/3的漏洞来自内核模块或者驱动程序，1/3来自内核自身。
## 2.1. 指针未检查
内核代码在对内核空间读写是，没有检查操作的指针是否只应该指向用户空间，而导致无权限的进程对内核空间读写。
例如CVE-2010-4258，在漏洞代码中，如果tsk->clear_child_tid不为空，就会调用put_user（0， tsk->clear_child_tid），将指针指向的内存置零，整个过程只会调用access_ok来检查指针是否合法，但是这个检查只需要get_fs() = KERNEL_DS就会返回1，而不检查指针，往往一些内核bug产生时候，就会满足get_fs() = KERNEL_DS的条件，导致了内核空间任意地址置零。
## 2.2. 权限未检查
一些本应该只允许特权用户才能进行的操作或者访问的文件，因为调用或者访问时没有进行权限检查，导致越权。
## 2.3. 缓冲区溢出
分配的缓冲区大小小于实际内容或者在写入缓冲区时没有对内容大小作检查，导致缓冲区溢出，可能导致信息泄露、提权、控制流劫持等问题。
## 2.4. 整形溢出
可能导致一些检查被绕过，从而出现缓冲区溢出或者信息泄露。
## 2.5. 变量未初始化
内核一些数据结构内存空间可能比实际内容要大，导致引入了一些“空隙”，没有被初始化时，这些空隙可能会包含之前的函数调用栈内容之类的敏感信息，当这些数据被Copy_to_user等函数拷贝到用户空间时就造成了信息泄露，例如泄露一个栈上指针可以被用来计算进程基地址（stackjack攻击）。
## 2.6. 内存管理错误
Use-after-free、Double free、memory leak、外部内存消耗等漏洞，可能造成拒绝服务攻击。
## 2.7. MISC混合类型
空指针引用、被0除、死循环、data races等漏洞。
# 3. 防御分析
## 3.1. Runtime tools
### 3.1.1. Software fault isolation
BGI可以隔离内核模块，控制内核模块之间的交互，但是防不了core中的漏洞或者只在一个module范围内的漏洞。
### 3.1.2. Code Integrity
SecVisor通过一个小的hypervisor来监控所有内核模式执行的代码来源，但可以被控制流劫持、破坏内存数据等攻击绕过。
### 3.1.3. User-level Drivers
SUD在用户态运行设备驱动，虽然防止了驱动漏洞影响内核，但是还是会形成DoS攻击。
### 3.1.4. Memory tagging
Rakasha会监控内核代码使用不信任的输入，只能防御控制流替换这一类攻击。
### 3.1.5. 未初始化内存跟踪
Kmemcheck通过kernel memory allocator跟踪内存每字节的初始化情况。Secure deallocation周期性的将内核栈置0。两种方法都只能缓解漏洞，并不能完全防御。
## 3.2. Compile-time tools
静态分析工具会产生大量误报，而且解决不了语义漏洞，但是在空指针引用、缓冲区溢出、死锁、死循环检测上有了良好效果。
# 4. 论文总结
这篇short paper确实很短，但是这类综述类型的文章想要完全弄懂需要很多的知识，读的时候通过查询这些CVE的细节都可以学到很多真实的漏洞细节，但是那些防御手段确实没有实践过，只能有一个模糊的概念。这篇文章对漏洞的整理还是让人对内核漏洞情况有了一个清晰的认识。