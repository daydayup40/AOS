# 《Hyperkernel》阅读报告

# 论文概述
之前虽然有工作试图形式化的证明一个操作系统内核的正确性，但是需要大量的人力。为此本文提出了一种利用Z3求解器来简单的自动化证明内核正确性的方法，并且基于此生成了hyperkernel这一个基于xv6的内核，经过验证，hyperkernel可以避免xv6存在的一些bug
# 挑战
Hyperkernel的关键挑战之一是接口设计，它需要在可用性和校验自动化之间取得平衡：一方面，内核维护着一套丰富的数据结构和不变式来管理进程，虚拟内存和设备等资源。因此，Hyperkernel接口需要支持对高级属性（例如，进程隔离）的规范和验证，这些属性为推理用户应用程序的正确性提供了基础。另一方面，这个接口也必须以一种能够用SMT解算器完全自动验证这些属性的方式来实现。
第二个挑战来自内核代码中的虚拟内存管理。 内核虚拟内存通常不是单射 - 对一个内核内存地址的写入可以改变另一个地址的值，因为两个虚拟地址可能映射到相同的物理地址，在这种设置中证明关于内核代码的属性特别困难，需要推理关于虚拟地址到物理地址的映射。
第三个挑战，C语言是一种已知使形式推理复杂化的编程语言。 由于诸如指针算术和存储器访问等低级操作，对C程序的C语义和原因进行准确建模显然是困难的。 另外，C标准有意不明确，允许编译器利用未定义的行为来生成高效的代码。

为此Hyperkernel设定了三个条件：
- 内核接口被设计为有限的
	- 系统调用，异常和中断的所有处理程序（本文中统称为trap handler程序）都没有无限循环和递归，从而可以编码和 使用SMT验证它们。
- Hyperkernel中内核和用户空间内存分离
	- 使用内核的身份映射; 这简化了关于内核代码的推理。 为了有效地实现这种分离，Hyperkernel使用Intel VT-x和AMD-V提供的x86虚拟化支持：内核和用户进程分别使用单独的页表在host和guest模式下运行。
- Hyperkernel在LLVM中间表示（IR）级别执行验证
	- LLVM IR语义比C更简单，同时保持足够高的级别以避免关于机器细节的推理。
# basic idea
文章以dup系统调用为例，verifier将基于python的spec和implementation（从C编译的LLVM IR）都转换为SMT语句，并调用Z3执行验证。验证后的代码与未验证的（可信的）代码链接以生成最终的内核映像。(可信代码：包括规范，定理，内核初始化，glue code，验证器，依赖的工具链（Z3，Python，LLVM），硬件的正确性)

## 有限接口定义
接口里的操作次数需要允许找到一个比较小的常数作为上界

## spec描述
- 状态机规格说明书
- 声明规格说明书

## 定理
- 正确的内核实现是状态机规格说明书的细化
- 状态机的规范满足声明的规范
# Verifier
## Modeling kernel behavior
在验证器中，作者的核心观点是将状态机中内核相关的属性进行编码，确保其在 Z3 中可用。其采用的方法是对内核的执行流进行建模，构造相应的状态机。状态转换发生的时候，要求 trap handling 代码操作是原子的，即运行 trap handler 时关闭中断，直到结束再次开启。同时，DMA 可能会异步改变内存，作者采用Intel’s VT-d Protected Memory Regions 或者 AMD’s Device Exclusion Vector 的方法将 DMA 限制到一个独立的区域，以便于更好的验证。

为了证明内核的正确性（定理1），验证器计算每个转换函数f以及表示不变量I（对于所有状态转换都是相同的）的fspec和fimpl的SMT编码。 验证器然后要求Z3证明定义1中公式的有效性，表明它的否定是不可满足的。验证器通过评估用Python编写的状态机规范来计算fspec。

为了计算fimpl和I，它在内核代码的LLVM IR上执行符号执行，遍历所有路径。

如果Z3发现查询不可满足，验证成功。 否则，如果Z3返回一个反例，则验证器会生成一个测试用例。

为了证明横切属性P（定理2），验证器从各自的规范（在Python中）计算P和fspec的SMT编码，并且在定义2中的公式的否定上调用Z3，再同上定理一
# Hyperkernel
## overview
- Dune + exokernels + seL4
	- 内核和用户内存分离
	- 减少内核中断处理，将一部分中断丢给用户空间
- 用户进行资源申请
	- 内核只负责验证资源可用，这种方式保证是finite的
- Typed pages内存分区
## Designing finite interfaces
- Enforcing resource lifetime through reference counters
- Enforcing fine-grained protection
  - 使用 exokernel 的方式创建进程
  - 大部分工作交给用户空间的库
- Validating linked data structures
  - 用户空间可以自己想办法快速寻找空闲资源
## Limitations
- 使用虚拟化技术，导致hypercall需要开销
- 需要finite接口设计
- 只支持单核

## checker

Hyperkerner定理为trap handler程序提供了正确性保证。但是，它们不包括内核初始化或glue代码（直接作为了可信代码）。验证这些组件将需要为x86构建一个机器级规范（包括硬件虚拟化）。
- Boot checker
- stack checker： LLVM IR不对机器细节（如stack）进行建模。因此，验证Hyperkernel（处于LLVMIR级别）不会排除由于堆栈溢出导致的运行时故障。我们对由LLVM后端生成的x86程序集实施静态检查;它会构建调用图并保守地估计trap handler程序使用的最大堆栈空间。运行检查程序显示它们都在内核堆栈大小（4 KiB）内执行。
- link checker。验证者假定LLVM IR中的符号不重叠。我们实现了一个静态检查器，以确保链接器在最终的内核映像中维护这个属性。检查器从内核映像读取每个符号的内存地址和大小，并检查所有符号是否位于不相交的内存区域

# 论文总结
文章可以明显的感觉到在系统的易证明性和系统可用性之间折中，为了系统的易证明性，系统不能太复杂，很多的功能会让证明变得很复杂，但是如果全部去掉，这个系统又显得太玩具了，最终文章权衡出了hyperkernel。论文使用Z3和llvm IR的方法做出了一个尝试，从这篇文章里可以感受到一个比较好的基于python的spec原来可以用程序良好的解析，打破了对之前文字版规格说明书死板难用的印象。