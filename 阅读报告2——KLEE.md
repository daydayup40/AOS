#《KLEE》阅读报告
# 1. 论文概述
本文是符号执行方面的一个十分经典的工作，KLEE的开源使得很多符号执行的工具基于KLEE开发。文章主要介绍了KLEE的架构以及一些对于符号执行的优化细节，并对89个GNU COREUTILS utility suite程序进行了大规模的测试，在代码覆盖率和bug发现上取得了非常好的结果。
# 2. KLEE
之前的符号执行方法都面临两个问题：1.路径指数级增长；2.如何获取来自周围环境交互的输入。KLEE对这两个问题进行了优化，并且在约束求解、简化约束表示、路径搜索策略上进行了改进。
使用KLEE前，先将待测程序源码用llvm编译成bytecode的形式，因为KLEE直接读取llvm的汇编指令获取约束。编译完成后，KLEE会模拟一个操作系统读取llvm指令执行目标程序，在遇到分支的时候使用约束求解器STP看当前约束满足哪一条分支，如果都满足则进行fork，当前进程进入一条分支，一个新的进程进入另一条分支；如果只能进入一条分支，下次执行到这个地方的时候约束求解器会对当前分支约束取反以进入另一条。在执行过程中，KLEE会对如指针解引用之类的危险操作进行检查，看是否有可能触发异常错误（具体如何检查错误文章没有细说，没有很理解）。
## 2.1. 架构
KLEE是一个符号化进程操作系统和一个解释器的混合体，直接解析程序使用LLVM汇编指令集，并且直接将指令映射到约束。
KLEE的核心是一个解释器循环，每次挑选一个state运行，state以树的形式进行存储，包括寄存器、堆、栈信息，树的叶子节点是符号变量或者常量，中间节点是llvm汇编指令。KLEE使用一个指令指针来表示当前条件是true还是false。
## 2.2. 优化
### 2.2.1. 简化state的表示
State因为路径数目会得到爆炸性的增长，因此state要尽量简洁，减少空间占用。KLEE可以跟踪所有内存对象，因此可以实现对象粒度的Copy-on-write，可以急剧减少资源占用——KLEE将堆结构实现为一个固定的映射，这样部分堆结构可以在不同state之间共享。这个方法还可以大大简化缓存和搜索策略的实现。
### 2.2.2. 查询优化
在符号执行中，约束求解的开销一直居于所有开销之首，为此尽量减少约束求解的查询可以大大提高性能。KLEE优化如下：
    1） 表达式重写：尽量简化表达式，使用类似编译器里优化的方法，例如x+0优化成x。
    2） 约束集简化：当有新的约束加入的时候，这个约束可能强于其他相关约束，因此可以将其他较弱的关于相同变量的约束从约束集中移除。
    3） 使用具体值：如果出现类似x+1=10这样的约束，可以直接将x替换成常数9
    4） 独立约束求解：对于某个条件只关于一个变量，那么约束集里与这个变量无关的约束就不需要在这个条件被考虑。
    5） 约束缓存：使用UBTree结构实现的一个缓存映射，可以高效率的查询。缓存机制非常有效，因为约束集有很多特性：如果约束集子集无解，那么约束集也无解；约束集有解则子集一定有解；可以父集约束的解直接作为子集约束的解。
这些优化策略将约束求解的开销缩小了20倍，效果非常好。
### 2.2.3. State调度策略
KLEE的state调度策略使用的是两个策略轮询的方式：
    1） 随机路径选择：KLEE用二叉树表示所有state里的程序路径，在每个分支等概率的随机选择一条路径，这种方法可以保证较高位置的节点（约束更少）更容易被选择，而且不会出现节点一直不被执行的问题。
    2） 路径覆盖策略：这种策略会对每个state计算一个权值，权值计算根据离未执行代码最小距离、state调用栈、是否最近执行过新代码等信息。
## 2.3. 环境建模
之前的符号执行工作都被很难获得外界环境交互的输入所困扰，KLEE使用对特定的交互环境建模的方式来解决这个问题。
环境建模主要目的是想要获得所有的输入值，而不是仅仅某一个具体值，KLEE对每一个使用C语言实现一个模型，这个模型可以理解和环境交互代码的语义来生成约束，KLEE只需将与环境交互前先将交互重定向到这个模型里，通过模型交互就可以获得环境输入了。有的测试程序需要捕获system call调用异常，KLEE实现了一个模拟syscall异常的可选功能在模型中。
但是这种方法存在一个问题，即需要对每个环境都要自己编程实现一个模型，这个过程需要人力，而且容易出现bug。
KLEE使用了重放测试用例的驱动程序来重新执行约束求解得到测试用例，为了防止重新执行时出现system call异常导致KLEE崩溃，KLEE使用ptrace调试接口建立了一个简单的工具来跳过可能出错的system calls。
# 3. 论文总结
论文对符号执行的工具具体实现进行了描述，确实以前只知道符号执行的原理，但是符号执行是通过fork机制走不同分支、自己模拟了一个process数据结构等这类实现方式都没有了解，因此很有收获，要想有更深刻的认识，还是要亲自去用上这些工具才能有体会。
这篇工作的Evaluation非常有名而且有一些年头了，因此没有仔细去了解了。