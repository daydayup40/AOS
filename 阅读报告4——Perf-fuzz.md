# 《Designing New Operating Primitives to Improve Fuzzing Performance》阅读报告

# 1.论文概述
论文为解决AFL在多核机器并行fuzzing是存在的性能瓶颈问题，做出了三点改进，包括编写了新的比fork更加轻量级的系统调用snapshot；使用双文件系统，将fuzz的临时文件读写都放在tmpfs之类的内存文件系统里进行；使用了共享内存的测试用例共享日志。这些优化使得fuzzing程序在多核并发情况下性能显著提升。

# 2. AFL的设计
AFL为了避免大量执行execve()这个相对比较耗时间的函数，采用了fork机制，对于每一个输入，将正在运行的程序进程fork后继续执行，因为fuzzing会产生数百万个输入，因此fork系统调用会被大量使用，但是fork系统调用里很多的操作都是fuzzing不需要用到的，例如fork需要更新物理页的映射。
每次变异生成测试用例后，AFL会把测试用例写入到.cur_input这一个文件中，并且会对各种状态记录文件进行更新，这些操作都会造成对文件系统的大量读写。
AFL支持并行fuzzing来充分利用多核机器上的cpu资源，这种情况下，每个AFL实例独立执行，彼此之间都是平等的并行操作，每个AFL实例维护自己的一个私有工作目录。为此，每个AFL实例在并行工作的时候需要同步各自的状态来保证每个输入不被重复使用，这种同步在cpu足够多的时候，带来的开销甚至会高于fuzzing自身的开销。
# 3. AFL的性能测试
作者用AFL对JPEG decompressor这个程序进行了fuzzing，使用的核心数从1增加到120。在15核的时候达到了瓶颈，在45核的时候，操作系统内核成为了主要的瓶颈。
# 4. 优化
## 4.1. Snapshot系统调用
Snapshot是一个设计的比fork更加轻量级，为fuzzing定制的系统调用，节省了大量时间来复制大量内核数据结构（例如文件描述符，内存描述符，信号和命名空间），还避免了建立安全和审计结构的新副本并为快照处理分配新的堆栈区域，此外，snapshot在同一进程内进行，消除了进程调度开销。Snapshot可以根据fuzzing的状态分为三个步骤。
### 4.1.1. fuzzing之前
Snapshot需要保存当前进程的信息和上下文，目标进程使用sigsetjmp()保存用户空间执行上下文ctx，包括所有当前的寄存器值和信号掩码。然后进入一个循环不断等待来自fuzzer的新的fuzzing请求。接收到请求后，进程使用BEG_SNAPSHOT作为参数调用snapshot保存内核上下文并注册一个回调函数，下面是BEG_SNAPSHOT作为参数时，snapshot对内核的操作：
    1） Virtual Memory Area (VMA)：snapshot()迭代进程的虚拟内存区域（即vmas）并临时存储每个vma的开始和结束地址。
    2） Page：snapshot()会维护一组属于可写vma的页（因为目标应用程序可能会修改这些可写页面，当应用程序终止时，内核应该恢复到原始状态）。 为了跟踪这些可写页并保持初始的内存状态，使用了Copy-on-write技术。先通过更新其相应的页表项（PTE），刷新TLB，将可写页面的权限更改为只读。于是，这些页上的任何写入都会导致页错误，我们定制的页错误处理程序会捕获并处理页错误。作者的一个优化还包括：不更改内核尚未分配物理页面的映射好的可写虚拟地址的权限（因为这些页上的内存访问总是会导致页错误）。
    3） Brk：snapshot()会保存brk值，来保存进程堆区域范围信息。
    4） File descriptor：snapshot()通过检查文件描述符表和bitmap（open_fds）来获取文件描述符打开情况并保存，以便于后面的恢复。
除了修改这些数据结构外，snapshot()还保存已注册的回调函数。 当快照好的进程即将完成fuzzing或者中间退出时（例如，调用exit()），snapshot()可以安全地将控制流重定向到用户空间中的callback()函数。
### 4.1.2. Fuzzing时

 这个过程主要解决page的写问题。目标进程从snapshot()返回后，继续使用运行时的参数和环境变量执行，当需要写入页时会发生页错误，页错误由页错误处理程序来负责，先检查这个页是否是在最初快照的页列表中，如果是，则在PTE中增加写权限，并且写入页面的副本（Copy-on-write）；而对于没有相应物理页面的页，只需要分配新的页，并且在PTE中增加写权限。最后刷新TLB。
### 4.1.3. Fuzzing后
这个阶段主要是要恢复到snapshot()之前的时候了。如果正常结束fuzzing，即子进程从main退出，会先把进程结束信息告诉父进程fuzzer。对于调用exit()退出的情况，修改了sys_exit_group的入口函数并检查进程是否被快照，如果是被snapshot了的进程，会调用用户空间中的callback函数。如果程序发出了SIGSEGC或者SIGALARM，每种信号注册的一个信号处理程序会调用相应的exit status的callback函数，并且将退出的状态告知父进程fuzzer。
Callback函数被调用后，进程使用END_SNAPSHOT参数调用snapshot()恢复原始快照状态，之后进程在调用siglongjmp()恢复用户空间上下文，然后进入循环，等待fuzzer的信号。使用END_SNAPSHOT参数调用snapshot()会进行4个清理步骤：
1）Recovering copied pages：snapshot()恢复保存了初始内容的页，释放分配的物理内存，恢复相应的PTE，并刷新相应的TLB。
2）Adjusting memory layout：snapshot()再次迭代目标进程的VMA，并取消映射所有新近映射的虚拟内存区域。
3）Recovering brk：进程的brk值影响堆分配，将其恢复到保存的brk值。
4）Closing opened file descriptors：通过比较当前和过去fuzzing运行之前保存的文件描述符以及bitmap，snapshot()找到fuzzing过程中打开的文件描述符并关闭它们。

## 4.2.双文件系统

 所谓的双文件系统其实非常简单，就是把每个fuzzing实例的私有工作目录不放在磁盘上而是放在tmpfs之类的内存文件系统上，同时一个清理程序为了保证内存文件系统的空间不溢出导致文件丢失，不停的将内存文件系统中一些优先级较低的文件移到磁盘上。

 内存文件系统减少了fuzzing对磁盘文件系统大量的读写，节省了很多开销。

## 4.3.基于共享内存的测试用例日志

 为了优化在同步测试用例执行状态时，AFL需要不停的访问其他实例的私有工作目录，低效率同步的问题，使用了一个放在共享内存里的保存测试用例执行信息的数据结构——test-case log。测试用例日志是一个固定大小的内存循环日志，日志的每个元素都存储测试用例的信息，包括文件名，大小，路径hash和trace_bit。只有master实例才有权限进行push，任何slave都可以进行pop，为保证性能，test-case log并没有使用锁。
# 5.实现
作者在ubuntu的linux-4.8.0内核中实现了snapshot()系统调用（750 LoC），编写了一个基于/dev/shm的简单双文件守护进程（100 LoC），重写了AFL的snapshot server（350 LoC），增加了同步代码（50 LoC）。
# 6.论文总结
这篇论文提升了AFL的并行性能，并且进行了代码开源，可以实际用到自己的研究中去。文章的想法其实并不复杂，但是这一系列的优化实现有很大的工程量，需要很扎实的学习系统相关知识。